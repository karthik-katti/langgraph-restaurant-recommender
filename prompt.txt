from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder

extract_prompt = ChatPromptTemplate.from_messages([
    ("system", """You are a hotel recommendation assistant. 
Your goal is to extract the following structured data from the entire conversation history and latest user input:

    - city: Must be one of New York, Los Angeles, Seattle, Las Vegas.
    - cuisine: A list of cuisines such as ["Asian", "American", "Italian"].

Return valid JSON only in the format:
{
  "city": "<city or null>",
  "cuisine": ["cuisine1", "cuisine2"] or null,
  "response": "<message to user>"
}

Rules:
1. Always output *only* valid JSON, no extra text or explanation.
2. If city is not in [New York, Los Angeles, Seattle, Las Vegas], set "city" to null and "response" to:
   "City not supported. Supported cities are New York, Los Angeles, Seattle, Las Vegas."
3. If all fields (city, cuisine) are present, set "response" to "Ready to search".
4. If any field is missing, ask for the missing one politely.
5. If the user provides a new cuisine and the last known city is already known (from prior conversation),
   ask: "Would you like this cuisine for the same city (<city>) or a new city?"
   unless the input explicitly includes a city name.
6. If the user clarifies "same city", reuse the previously known city.
7. If the user says a new city name, update the city.
8. For cuisine, handle formats like "Asian, American" or "Asian,American" → ["Asian", "American"].
9. If the input is unclear, respond with a clarification request.

Examples:
- Input: "Restaurant in New York", History: "", 
  Output: {"city": "New York", "cuisine": null, "response": "Please provide cuisine details (e.g., American, Asian, Italian)."}

- Input: "American", History: "human: Restaurant in New York", 
  Output: {"city": "New York", "cuisine": ["American"], "response": "Ready to search"}

- Input: "Japanese", History: "human: Restaurant in Seattle\nai: Please provide cuisine details.\nhuman: American\nai: Ready to search", 
  Output: {"city": "Seattle", "cuisine": ["Japanese"], "response": "Would you like this cuisine for the same city (Seattle) or a new city?"}

- Input: "Same city", History: (previous example), 
  Output: {"city": "Seattle", "cuisine": ["Japanese"], "response": "Ready to search"}

History and prior context:
{messages}"""),
    MessagesPlaceholder(variable_name="messages"),
    ("user", "{input}")
])





extract_prompt = ChatPromptTemplate.from_messages([
    ("system", """You are a hotel and restaurant recommendation assistant.
You help users find restaurants by **city** and **cuisine**.

You have access to previously known data:
- Previous city: {city}
- Previous cuisines: {cuisine}

Your goal:
1. Extract the current city and cuisine(s) from user messages.
2. Output ONLY valid JSON:
   {{
     "city": "<city or null>",
     "cuisine": ["cuisine1", "cuisine2"] or null,
     "response": "<message to user>"
   }}

Rules:
- Supported cities: New York, Los Angeles, Seattle, Las Vegas.
- If user provides:
  a) Only a **cuisine** (no city):
      → Ask: "Would you like this cuisine for the same city (<previous city>) or a new city?"
  b) Only a **city** (no cuisine):
      → Ask: "Would you like this city for the same cuisine (<previous cuisine>) or a new cuisine?"
- If user says "same city" or "same cuisine", reuse previous value.
- If user provides new city/cuisine, update accordingly.
- If both city and cuisine are known, respond with "Ready to search."
- If city not supported, set city = null and respond accordingly.
- Keep responses short and polite.
"""),
    MessagesPlaceholder(variable_name="messages"),
    ("user", "{input}")
])





extract_prompt = ChatPromptTemplate.from_messages([
    ("system", """You are a hotel and restaurant assistant.

You have full access to the conversation history.

Rules:
1. Supported cities: New York, Los Angeles, Seattle, Las Vegas.
2. If user provides both city and cuisine → respond "Ready to search".
3. If user provides only a cuisine → ask: 
   "Would you like this cuisine for the same city (<last city>) or a new city?"
4. If user provides only a city → ask: 
   "Would you like this city for the same cuisine (<last cuisine>) or a new cuisine?"
5. If user says "same city" or "same cuisine", infer what they mean using the conversation history.
6. Always output valid JSON:
   {{
      "response": "<assistant reply>"
   }}
7. Keep responses concise and polite.
"""),
    MessagesPlaceholder(variable_name="messages"),
    ("user", "{input}")
])






llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)

def process_input(state: AgentState) -> AgentState:
    messages = state.get("messages", [])
    latest_input = messages[-1].content if messages else ""

    chain = extract_prompt | llm
    result = chain.invoke({"messages": messages, "input": latest_input})

    try:
        parsed = json.loads(result.content)
        reply = parsed.get("response", "Sorry, I could not understand that.")
    except Exception:
        reply = "Sorry, I could not parse the response."

    return {"messages": messages + [AIMessage(content=reply)]}




graph = StateGraph(AgentState)
graph.add_node("process_input", process_input)
graph.add_edge(START, "process_input")
graph.add_edge("process_input", END)

app = graph.compile(checkpointer=checkpointer)




thread_id = "user77"

# 1️⃣ User mentions city
s1 = app.invoke(
    {"messages": [HumanMessage(content="I want a restaurant in Seattle")]},
    config={"configurable": {"thread_id": thread_id}}
)
print("AI:", s1["messages"][-1].content)

# 2️⃣ User mentions cuisine
s2 = app.invoke(
    {"messages": [HumanMessage(content="American")]},
    config={"configurable": {"thread_id": thread_id}}
)
print("AI:", s2["messages"][-1].content)

# 3️⃣ User mentions new cuisine only
s3 = app.invoke(
    {"messages": [HumanMessage(content="Japanese")]},
    config={"configurable": {"thread_id": thread_id}}
)
print("AI:", s3["messages"][-1].content)

# 4️⃣ User mentions new city only
s4 = app.invoke(
    {"messages": [HumanMessage(content="Los Angeles")]},
    config={"configurable": {"thread_id": thread_id}}
)
print("AI:", s4["messages"][-1].content)



AI: Please provide cuisine details (e.g., American, Asian, Italian).
AI: Ready to search.
AI: Would you like this cuisine for the same city (Seattle) or a new city?
AI: Would you like this city for the same cuisine (American) or a new cuisine?




Notes

The LLM decides everything: last city/cuisine, whether “same city” or “same cuisine” applies.

The state remains just messages, so persistence is simpler.

Multiple mentions of cities/cuisines are handled naturally by the LLM reading history in chronological order.
